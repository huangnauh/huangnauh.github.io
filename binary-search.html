<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->

### 1 “经典”版本
采用闭区间

在计算`mid = (low+high)/2;` 的时候，`(low + high)` 可能溢出
```
int binary_search(int a[],int n,int target)
{
    int low = 0,high = n-1;
    while(low <= high){
        int mid = low + (high-low)/2;
        if(a[mid] == target){
            return mid;
        }else if(a[mid] > target){
            high = mid-1;
        }else{
            low = mid+1;
        }
    }
    return -1;
}
```

### 2 查找符合目标的最小下标
如果没有找到，返回插入的位置信息。插入需要元素个数+1个位置。
采用半开半闭区间`[low， high)`
```
int binary_search_first_position(int a[],int n,int target)
{
    int low = 0,high = n;
    while(low < high){
        int mid = low + (high-low)/2;
        if(a[mid] < target){
            low = mid+1;
        }else{
            high = mid;
        }
    }
    if(low >= n || a[low] != target)
        return -low-1; //low是比目标值大的那个位置
        //一次加一取反，即可获得需要插入新元素的位置。减 1 是为了避免 low 为 0 时，被误认为目标存在。
    else:
        return low;
}
```



### 3 查找符合目标的最大下标
如果没有找到，返回插入的位置信息。

采用半开半闭区间`(low， high]`
```
int binary_search_last_position(int a[],int n,int target){
    int low = -1,high = n-1;
    while(low < high){
        int mid = high-(high-low)/2;
        if(a[mid] > target){
            high = mid-1;
        }else{
            low = mid;
        }
    }
    if(high<0 || a[high] != target)
        return -(high+1)-1;//high是比目标值小的那个位置
        //一次加一取反，即可获得需要插入新元素的位置。减 1 是为了避免 high+1 为 0 时，被误认为目标存在。
    else
        return high;
}
```

### 4 开区间`(low, high)`
循环不变式:如果目标值存在于数组中，那么它的索引必然存在于开区间`(low, high)`，其中`low + 1 < high`
```
int binary_search(int a[],int n,int target){
    int low = -1,high = n;
    while(low+1 < high){
        int mid = low + (high-low)/2;
        if(a[mid] < target){
            low = mid;
        }else{
            high = mid;
        }
    }
    if(high >= n || a[high]!=target)
        return -high-1;
    else
        return high;
}
```

```
int binary_search_last_position(int a[],int n,int target){
    int low = -1,high = n;
    while(low+1 < high){
        int mid = low + (high-low)/2;
        if(a[mid] > target){
            high = mid;
        }else{
            low = mid;
        }
    }
    if(low < 0 || a[low] != target){
        return -high-1;
    }else{
        return low;
    }

}
```
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h3 id="1">1 “经典”版本</h3>

<p>采用闭区间</p>

<p>在计算<code>mid = (low+high)/2;</code> 的时候，<code>(low + high)</code> 可能溢出</p>

<pre><code>int binary_search(int a[],int n,int target)
{
    int low = 0,high = n-1;
    while(low &lt;= high){
        int mid = low + (high-low)/2;
        if(a[mid] == target){
            return mid;
        }else if(a[mid] &gt; target){
            high = mid-1;
        }else{
            low = mid+1;
        }
    }
    return -1;
}
</code></pre>

<h3 id="2">2 查找符合目标的最小下标</h3>

<p>如果没有找到，返回插入的位置信息。插入需要元素个数+1个位置。
采用半开半闭区间<code>[low， high)</code></p>

<pre><code>int binary_search_first_position(int a[],int n,int target)
{
    int low = 0,high = n;
    while(low &lt; high){
        int mid = low + (high-low)/2;
        if(a[mid] &lt; target){
            low = mid+1;
        }else{
            high = mid;
        }
    }
    if(low &gt;= n || a[low] != target)
        return -low-1; //low是比目标值大的那个位置
        //一次加一取反，即可获得需要插入新元素的位置。减 1 是为了避免 low 为 0 时，被误认为目标存在。
    else:
        return low;
}
</code></pre>

<h3 id="3">3 查找符合目标的最大下标</h3>

<p>如果没有找到，返回插入的位置信息。</p>

<p>采用半开半闭区间<code>(low， high]</code></p>

<pre><code>int binary_search_last_position(int a[],int n,int target){
    int low = -1,high = n-1;
    while(low &lt; high){
        int mid = high-(high-low)/2;
        if(a[mid] &gt; target){
            high = mid-1;
        }else{
            low = mid;
        }
    }
    if(high&lt;0 || a[high] != target)
        return -(high+1)-1;//high是比目标值小的那个位置
        //一次加一取反，即可获得需要插入新元素的位置。减 1 是为了避免 high+1 为 0 时，被误认为目标存在。
    else
        return high;
}
</code></pre>

<h3 id="4lowhigh">4 开区间<code>(low, high)</code></h3>

<p>循环不变式:如果目标值存在于数组中，那么它的索引必然存在于开区间<code>(low, high)</code>，其中<code>low + 1 &lt; high</code></p>

<pre><code>int binary_search(int a[],int n,int target){
    int low = -1,high = n;
    while(low+1 &lt; high){
        int mid = low + (high-low)/2;
        if(a[mid] &lt; target){
            low = mid;
        }else{
            high = mid;
        }
    }
    if(high &gt;= n || a[high]!=target)
        return -high-1;
    else
        return high;
}
</code></pre>

<pre><code>int binary_search_last_position(int a[],int n,int target){
    int low = -1,high = n;
    while(low+1 &lt; high){
        int mid = low + (high-low)/2;
        if(a[mid] &gt; target){
            high = mid;
        }else{
            low = mid;
        }
    }
    if(low &lt; 0 || a[low] != target){
        return -high-1;
    }else{
        return low;
    }

}
</code></pre>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "binary-search.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
